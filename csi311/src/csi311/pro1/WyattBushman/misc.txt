//Add back to parser....
    public Optional<Node> ParseExpression() {
        Optional<Node> left = ParseTerm();
        while (tokenManager.MoreTokens()) {
            TokenType nextTokenType = tokenManager.Peek(0).get().getType();
            OperationType operationType;
            switch (nextTokenType) {
                case PLUS:
                    operationType = OperationType.ADDITION;
                    break;
                case MINUS:
                    operationType = OperationType.SUBTRACTION;
                    break;
                default:
                    return left;
            }
            matchAndRemove(nextTokenType);
            Optional<Node> right = ParseTerm();
            if (!right.isPresent()) {
                throwParseException("Expected term after addition or subtraction operator");
            }
            left = Optional.of(new OperationNode(left.get(), right, operationType));
        }
        return left;
    }
    
    public Optional<Node> ParseTernary() {
        Optional<Node> condition = ParseLogicalOr();
        if (!condition.isPresent()) {
            return Optional.empty();
        }

        if (tokenManager.MoreTokens()) {
            Token nextToken = tokenManager.Peek(0).get();
            if (nextToken.getType() == TokenType.QUESTION) {
                matchAndRemove(TokenType.QUESTION);
                Optional<Node> trueCase = ParseOperation();
                if (!trueCase.isPresent()) {
                    throwParseException("Expected value for true case of ternary operation");
                }
                matchAndRemove(TokenType.COLON);
                Optional<Node> falseCase = ParseOperation();
                if (!falseCase.isPresent()) {
                    throwParseException("Expected value for false case of ternary operation");
                }
                return Optional.of(new OperationNode(condition.get(), trueCase, OperationType.TERNARY_CONDITION));  // Adjust the OperationType as needed
            }
        }

        return condition;
    }

    
    public Optional<Node> ParseLogicalOr() {
        Optional<Node> left = ParseLogicalAnd();
        while (tokenManager.MoreTokens() && tokenManager.Peek(0).get().getType() == TokenType.OR) {
            matchAndRemove(TokenType.OR);
            Optional<Node> right = ParseLogicalAnd();
            if (!right.isPresent()) {
                throwParseException("Expected expression after logical OR");
            }
            left = Optional.of(new OperationNode(left.get(), right, OperationType.LOGICAL_OR));
        }
        return left;
    }
    
    public Optional<Node> ParseLogicalAnd() {
        Optional<Node> left = ParseComparison();
        while (tokenManager.MoreTokens() && tokenManager.Peek(0).get().getType() == TokenType.AND) {
            matchAndRemove(TokenType.AND);
            Optional<Node> right = ParseComparison();
            if (!right.isPresent()) {
                throwParseException("Expected expression after logical AND");
            }
            left = Optional.of(new OperationNode(left.get(), right, OperationType.LOGICAL_AND));
        }
        return left;
    }
    
    public Optional<Node> ParseComparison() {
        Optional<Node> left = ParseExpression();
        while (tokenManager.MoreTokens()) {
            TokenType nextTokenType = tokenManager.Peek(0).get().getType();
            OperationType operationType;
            switch (nextTokenType) {
                case LT:
                    operationType = OperationType.LESS_THAN;
                    break;
                case GT:
                    operationType = OperationType.GREATER_THAN;
                    break;
                case LT_EQ:
                    operationType = OperationType.LESS_THAN_OR_EQUALS;
                    break;
                case GT_EQ:
                    operationType = OperationType.GREATER_THAN_OR_EQUALS;
                    break;
                case EQ_EQ:
                    operationType = OperationType.EQUALS;
                    break;
                case NOT_EQ:
                    operationType = OperationType.NOT_EQUALS;
                    break;
                default:
                    return left;
            }
            matchAndRemove(nextTokenType);
            Optional<Node> right = ParseExpression();
            if (!right.isPresent()) {
                throwParseException("Expected expression after comparison operator");
            }
            left = Optional.of(new OperationNode(left.get(), right, operationType));
        }
        return left;
    }
    

    
    public Optional<Node> ParseTerm() {
        Optional<Node> left = ParseFactor();
        while (tokenManager.MoreTokens()) {
            TokenType nextTokenType = tokenManager.Peek(0).get().getType();
            OperationType operationType;
            switch (nextTokenType) {
                case ASTERISK:
                    operationType = OperationType.MULTIPLICATION;
                    break;
                case DIVIDE:
                    operationType = OperationType.DIVISION;
                    break;
                case MODULO:
                    operationType = OperationType.MODULUS;
                    break;
                default:
                    return left;
            }
            matchAndRemove(nextTokenType);
            Optional<Node> right = ParseFactor();
            if (!right.isPresent()) {
                throwParseException("Expected factor after multiplication, division, or modulus operator");
            }
            left = Optional.of(new OperationNode(left.get(), right, operationType));
        }
        return left;
    }
    
    public Optional<Node> ParseFactor() {
        Optional<Node> base = ParseBottomLevel();
        if (tokenManager.MoreTokens() && tokenManager.Peek(0).get().getType() == TokenType.EXPONENT) {
            matchAndRemove(TokenType.EXPONENT);
            Optional<Node> exponent = ParseFactor();  // recursion to handle right-associativity
            if (!exponent.isPresent()) {
                throwParseException("Expected expression after '^'");
            }
            return Optional.of(new OperationNode(base.get(), exponent, OperationType.EXPONENTIATION));
        }
        return base;
    }
    
    public Optional<Node> ParseExponentiation() {
        Optional<Node> base = ParseBottomLevel();
        if (!base.isPresent()) {
            return Optional.empty();
        }
        
        if (!tokenManager.MoreTokens()) {
            return base;
        }
        
        Token nextToken = tokenManager.Peek(0).get();
        if (nextToken.getType() == TokenType.EXPONENT) {
            tokenManager.MatchAndRemove(TokenType.EXPONENT);
            Optional<Node> exponent = ParseExponentiation();
            if (!exponent.isPresent()) {
                throw new RuntimeException("Expected an expression after '^'");
            }
            return Optional.of(new OperationNode(base.get(), exponent, OperationType.EXPONENTIATION));
        }
        
        return base;
    }
